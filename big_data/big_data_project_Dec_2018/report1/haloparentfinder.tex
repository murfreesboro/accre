%!TeX encoding = UTF-8
%!TeX program = xelatex
\documentclass[notheorems, aspectratio=54]{beamer}
% aspectratio: 1610, 149, 54, 43(default), 32

\usepackage{latexsym}
\usepackage{amsmath,amssymb}
\usepackage{mathtools}
\usepackage{color,xcolor}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{amsthm}
\usepackage{lmodern} % 解决 font warning
% \usepackage[UTF8]{ctex}
\usepackage{animate} % insert gif

\usepackage{lipsum} % To generate test text 
\usepackage{ulem} % 下划线，波浪线

\usepackage{listings} % display code on slides; don't forget [fragile] option after \begin{frame}
\usepackage{verbatim}
\makeatletter
\def\verbatim@font{\tiny\ttfamily}
\makeatother

% ----------------------------------------------
% tikx
\usepackage{framed}
\usepackage{tikz}
\usepackage{pgf}
\usetikzlibrary{calc,trees,positioning,arrows,chains,shapes.geometric,%
    decorations.pathreplacing,decorations.pathmorphing,shapes,%
    matrix,shapes.symbols}
\pgfmathsetseed{1} % To have predictable results
% Define a background layer, in which the parchment shape is drawn
\pgfdeclarelayer{background}
\pgfsetlayers{background,main}

\definecolor{AmethystPurple}{HTML}{AEAEDF}
% define styles for the normal border and the torn border
\tikzset{
  normal border/.style={AmethystPurple, decorate, 
     decoration={random steps, segment length=2.5cm, amplitude=.7mm}},
  torn border/.style={AmethystPurple, decorate, 
     decoration={random steps, segment length=.5cm, amplitude=1.7mm}}}

% Macro to draw the shape behind the text, when it fits completly in the
% page
\def\parchmentframe#1{
\tikz{
  \node[inner sep=1.5em] (A) {#1};  % Draw the text of the node
  \begin{pgfonlayer}{background}  % Draw the shape behind
  \fill[normal border] 
        (A.south east) -- (A.south west) -- 
        (A.north west) -- (A.north east) -- cycle;
  \end{pgfonlayer}}}

% Macro to draw the shape, when the text will continue in next page
\def\parchmentframetop#1{
\tikz{
  \node[inner sep=2em] (A) {#1};    % Draw the text of the node
  \begin{pgfonlayer}{background}    
  \fill[normal border]              % Draw the ``complete shape'' behind
        (A.south east) -- (A.south west) -- 
        (A.north west) -- (A.north east) -- cycle;
  \fill[torn border]                % Add the torn lower border
        ($(A.south east)-(0,.2)$) -- ($(A.south west)-(0,.2)$) -- 
        ($(A.south west)+(0,.2)$) -- ($(A.south east)+(0,.2)$) -- cycle;
  \end{pgfonlayer}}}

% Macro to draw the shape, when the text continues from previous page
\def\parchmentframebottom#1{
\tikz{
  \node[inner sep=2em] (A) {#1};   % Draw the text of the node
  \begin{pgfonlayer}{background}   
  \fill[normal border]             % Draw the ``complete shape'' behind
        (A.south east) -- (A.south west) -- 
        (A.north west) -- (A.north east) -- cycle;
  \fill[torn border]               % Add the torn upper border
        ($(A.north east)-(0,.2)$) -- ($(A.north west)-(0,.2)$) -- 
        ($(A.north west)+(0,.2)$) -- ($(A.north east)+(0,.2)$) -- cycle;
  \end{pgfonlayer}}}

% Macro to draw the shape, when both the text continues from previous page
% and it will continue in next page
\def\parchmentframemiddle#1{
\tikz{
  \node[inner sep=2em] (A) {#1};   % Draw the text of the node
  \begin{pgfonlayer}{background}   
  \fill[normal border]             % Draw the ``complete shape'' behind
        (A.south east) -- (A.south west) -- 
        (A.north west) -- (A.north east) -- cycle;
  \fill[torn border]               % Add the torn lower border
        ($(A.south east)-(0,.2)$) -- ($(A.south west)-(0,.2)$) -- 
        ($(A.south west)+(0,.2)$) -- ($(A.south east)+(0,.2)$) -- cycle;
  \fill[torn border]               % Add the torn upper border
        ($(A.north east)-(0,.2)$) -- ($(A.north west)-(0,.2)$) -- 
        ($(A.north west)+(0,.2)$) -- ($(A.north east)+(0,.2)$) -- cycle;
  \end{pgfonlayer}}}

% Define the environment which puts the frame
% In this case, the environment also accepts an argument with an optional
% title (which defaults to ``Example'', which is typeset in a box overlaid
% on the top border
\newenvironment{parchment}[1][Example]{%
  \def\FrameCommand{\parchmentframe}%
  \def\FirstFrameCommand{\parchmentframetop}%
  \def\LastFrameCommand{\parchmentframebottom}%
  \def\MidFrameCommand{\parchmentframemiddle}%
  \vskip\baselineskip
  \MakeFramed {\FrameRestore}
  \noindent\tikz\node[inner sep=1ex, draw=black!20,fill=AmethystPurple, 
          anchor=west, overlay] at (0em, 1em) {\sffamily#1};\par}%
{\endMakeFramed}

% ----------------------------------------------

\mode<presentation>{
    \usetheme{Berkeley}
    % Boadilla CambridgeUS
    % default Antibes Berlin Copenhagen
    % Madrid Montpelier Ilmenau Malmoe
    % Berkeley Singapore Warsaw
    \usecolortheme{dolphin}
    % beetle, beaver, orchid, whale, dolphin
    \useoutertheme{infolines}
    % infolines miniframes shadow sidebar smoothbars smoothtree split tree
    \useinnertheme{circles}
    % circles, rectanges, rounded, inmargin
}
% 设置 block 颜色
\setbeamercolor{block title}{bg=AmethystPurple,fg=white}

\newcommand{\reditem}[1]{\setbeamercolor{item}{fg=red}\item #1}

% 缩放公式大小
\newcommand*{\Scale}[2][4]{\scalebox{#1}{\ensuremath{#2}}}

% 解决 font warning
\renewcommand\textbullet{\ensuremath{\bullet}}

% verbatim


% ---------------------------------------------------------------------
% flow chart
\tikzset{
    >=stealth',
    punktchain/.style={
        rectangle, 
        rounded corners, 
        % fill=black!10,
        draw=white, very thick,
        text width=6em,
        minimum height=2em, 
        text centered, 
        on chain
    },
    largepunktchain/.style={
        rectangle,
        rounded corners,
        draw=white, very thick,
        text width=10em,
        minimum height=2em,
        on chain
    },
    line/.style={draw, thick, <-},
    element/.style={
        tape,
        top color=white,
        bottom color=blue!50!black!60!,
        minimum width=6em,
        draw=blue!40!black!90, very thick,
        text width=6em, 
        minimum height=2em, 
        text centered, 
        on chain
    },
    every join/.style={->, thick,shorten >=1pt},
    decoration={brace},
    tuborg/.style={decorate},
    tubnode/.style={midway, right=2pt},
    font={\fontsize{10pt}{12}\selectfont},
}
% ---------------------------------------------------------------------

% code setting
\lstset{
    language=C++,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{red},
    breaklines=true,
    xleftmargin=2em,
    numbers=left,
    numberstyle=\color[RGB]{222,155,81},
    frame=leftline,
    tabsize=4,
    breakatwhitespace=false,
    showspaces=false,               
    showstringspaces=false,
    showtabs=false,
    morekeywords={Str, Num, List},
}

% ---------------------------------------------------------------------

%% preamble
\title[Halo Parent Finder]{HaloParentFinder}
\subtitle{Big Data Project Transformation}
\author{Fenglai Liu}
\institute[ACCRE]{fenglai@accre.vanderbilt.edu}

% -------------------------------------------------------------

\begin{document}

%% title frame
\begin{frame}
    \titlepage
\end{frame}

% -------------------------------------------------------------

\begin{frame}
%    \frametitle{}

This program is about 2500 lines of code (including comments). Here below are the general 
procedure for the halo parent finding program:
\begin{itemize}
 \item Load in parameters. The global parameters are stored in a global struct PARAMS;
 \item Calculate the number of groups - group0 and group1;
 \item Allocate space for group0 and group1 and loading in the group data; 
 \item Finds the hierarchy level (this is for a single snapshot);
 \item Find fof parents for groups in group0 based on group1;
 \item Find all parents for groups in group0 based on group1;
 \item If the halo does not have parent, loop over the remaining snapshot data and repeat the previous steps.
\end{itemize}


\end{frame}

% -------------------------------------------------------------
\section{Components}

\subsection{Parameters Reading}
\begin{frame}
%    \frametitle{}

The codes for reading the parameters are in the read\_param.c and read\_param.h. The parameters defines
the location of the groups data(input), and output files directory; the limits of snapshots 
and other debugging options (one data file is a snapshot). The developer use a global variable PARAMS to store 
the parameters information. 

\end{frame}

% -------------------------------------------------------------
\subsection{Halo Groups}
\begin{frame}
%    \frametitle{}

``group'' is the central idea for this program - the structure of group is defined in io.h. Group is a collection of particles(Halo). One data file (snapshot)
may containing may groups.

\begin{block}{reading in the group data}
 \begin{itemize}
  \item first line is the the number of groups data;
  \item the following line is the N particles and the halo ID;
  \item after the lines are the particles data, like  x, y, z, vx, vy, vz etc. are all allocated based on the number of particles.
 \end{itemize}
\end{block}


In the code the group\_data pointer is an array of groups. The group data is initialized in the  the loadgroups
function.


\end{frame}

% -------------------------------------------------------------
\begin{frame}
%    \frametitle{}

\begin{block}{The drawback for the design of group data}
  \begin{enumerate}
   \item the design of the group data corresponding to the whole snapshot - not flexible to change. Each time for HaloParentFinder
   we need to load in the all group data in the snapshot, this is the core reason why the memory usage got problem. 
   \item allocate/free group data is cumbersome. Difficult to get the NGroups for the initialization.
   \item parent finding process only use a small portion of group data - however currently we need to carry the whole data 
   to do the process.
   \item the definition of the data structure is hard to modify.
   \item the coding style for the data structure is not clear for maintenance purpose.
  \end{enumerate}
\end{block}

\end{frame}

% -------------------------------------------------------------
\subsection{Functions}
\begin{frame}[fragile]
%    \frametitle{}

\begin{block}{Find Hierarchy}
 Finds the hierarchy level for each snapshot file (group0 and group1). 
\end{block}
This part may not be a costive part since it only runs for a single snapshot. Another point is, this function probably
is the only one uses the particle coordinates like $x$, $y$, $z$ and $xcen$, $ycen$ etc. in the group data.

Therefore, it implies that we can divided the whole group data into two parts:
\begin{itemize}
 \item Part I is for parent finding in terms of group and particles;
 \item Part II contains other data fields that not used for the parent finding. 
\end{itemize}
Such re-configuration can enhance the parent finding efficiency and memory usage.


\end{frame}

% -------------------------------------------------------------
\begin{frame}[fragile]
%    \frametitle{}

\begin{block}{Find fof parents and find all parent}
 \begin{verbatim}
loop over group data in group0:
     compare the ID from group1 with the group;
     update this group data in group0;
     update the corresponding group data in group1;
end loop
 \end{verbatim}
\end{block}
Both of the two functions contains similar structure like above. This will be the first key part for big data transformation
and for optimization. Especially for big data application, this part need to be carefully designed to avoid the communication 
penalty.

\end{frame}

% -------------------------------------------------------------
\begin{frame}[fragile]
%    \frametitle{}

\begin{block}{Find parents for remaining groups in group0}
 \begin{verbatim}
loop over remaining snapshot data files:
     free the group1 data array;
     initialize and load in the group1 data array;
     find hierarchy for group1;
     find fof parents and find all parent for group 
     data in group0;
end loop
 \end{verbatim}
\end{block}
this step is to reuse the previous functions so that to searching the remaining unknown parent halos.

\end{frame}

% -------------------------------------------------------------
\begin{frame}[fragile]
%    \frametitle{}

\begin{block}{Remaining functions: check\_fof\_matches and find\_progenitor}
both of the two functions has similar structure with parents finding functions, they are only used
for two adjacent snapshots.
 \begin{verbatim}
loop over group data in group1:
     search for matching group data in group0;
     update the group data in group1;
     update the group data in group0;
end loop
 \end{verbatim}
\end{block}

\end{frame}

% -------------------------------------------------------------
\section{Problems and Solutions}
\begin{frame}
%    \frametitle{}

\begin{block}{Biggest problem - code is hard to understand, maintain and improved} 
 \begin{itemize}
  \item abuse use of macro - mixing the debug codes with the production codes;
  \item rigid data structure - difficult for further improving;
  \item bad data structure design - the whole parent searching process is difficult 
  to maintain and change;
  \item use of global variables - strong coupling in the program.
 \end{itemize}
\end{block}

\begin{block}{Suggestion}
 The code needs to be rewritten. In general we can modify the codes so that to solve the memory
 problem, however in this way debugging cost is big. Rewriting may cost several weeks more but
 the final code will be easier for maintaining.
\end{block}

 
\end{frame}

% -------------------------------------------------------------
\begin{frame}

\begin{block}{Redesign the data structure}
 \begin{itemize}
  \item the normal group data for loading;
  \item group data for parent finding process;
 \end{itemize}
 Therefore the HaloParentFinder program at least should be divided into two modules. One module
 is to load the partial group data only for parent finding process
\end{block}

\end{frame}



% -------------------------------------------------------------
\subsection{Rigid Data Structure}
\begin{frame}
%    \frametitle{}

\begin{block}{Why memory is not sufficient?} 
The reason why memory is not sufficient is because the program needs to load in the whole snapshot data for computation. One computation needs two snapshots. For large enough snapshot like 150-200GB data this will cause the memory problem.
 \end{block}
 
\begin{block}{Suggestions}
\begin{itemize}
 \item If the group data in a snapshot is independent with each other, we can cut the large snapshot into smaller snapshots. 
 \item reorganize the code so that we can load in part of the snapshot data, rather than the 
 whole data file.
\end{itemize}
\end{block}

\end{frame}

% -------------------------------------------------------------
\begin{frame}
  
  \begin{block}{Using the global variable} 
  ``readshift'' array as an example:  used under macro ``SUSSING\_TREES''. In improving the program we need to consider
  the matching between snapshot data and redshift data.
 \end{block}
  
\end{frame}

% -------------------------------------------------------------
\subsection{Design of Scala}
\begin{frame}
  
\end{frame}


% -------------------------------------------------------------
\section{Features of Scala}
\subsection{Type inference for Scala}
\begin{frame}


\end{frame}


% -------------------------------------------------------------


\end{document}


