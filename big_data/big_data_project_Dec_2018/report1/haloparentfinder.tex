%!TeX encoding = UTF-8
%!TeX program = xelatex
\documentclass[notheorems, aspectratio=54]{beamer}
% aspectratio: 1610, 149, 54, 43(default), 32

\usepackage{latexsym}
\usepackage{amsmath,amssymb}
\usepackage{mathtools}
\usepackage{color,xcolor}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{amsthm}
\usepackage{lmodern} % 解决 font warning
% \usepackage[UTF8]{ctex}
\usepackage{animate} % insert gif

\usepackage{lipsum} % To generate test text 
\usepackage{ulem} % 下划线，波浪线

\usepackage{listings} % display code on slides; don't forget [fragile] option after \begin{frame}
\usepackage{verbatim}
\makeatletter
\def\verbatim@font{\tiny\ttfamily}
\makeatother

% ----------------------------------------------
% tikx
\usepackage{framed}
\usepackage{tikz}
\usepackage{pgf}
\usetikzlibrary{calc,trees,positioning,arrows,chains,shapes.geometric,%
    decorations.pathreplacing,decorations.pathmorphing,shapes,%
    matrix,shapes.symbols}
\pgfmathsetseed{1} % To have predictable results
% Define a background layer, in which the parchment shape is drawn
\pgfdeclarelayer{background}
\pgfsetlayers{background,main}

\definecolor{AmethystPurple}{HTML}{AEAEDF}
% define styles for the normal border and the torn border
\tikzset{
  normal border/.style={AmethystPurple, decorate, 
     decoration={random steps, segment length=2.5cm, amplitude=.7mm}},
  torn border/.style={AmethystPurple, decorate, 
     decoration={random steps, segment length=.5cm, amplitude=1.7mm}}}

% Macro to draw the shape behind the text, when it fits completly in the
% page
\def\parchmentframe#1{
\tikz{
  \node[inner sep=1.5em] (A) {#1};  % Draw the text of the node
  \begin{pgfonlayer}{background}  % Draw the shape behind
  \fill[normal border] 
        (A.south east) -- (A.south west) -- 
        (A.north west) -- (A.north east) -- cycle;
  \end{pgfonlayer}}}

% Macro to draw the shape, when the text will continue in next page
\def\parchmentframetop#1{
\tikz{
  \node[inner sep=2em] (A) {#1};    % Draw the text of the node
  \begin{pgfonlayer}{background}    
  \fill[normal border]              % Draw the ``complete shape'' behind
        (A.south east) -- (A.south west) -- 
        (A.north west) -- (A.north east) -- cycle;
  \fill[torn border]                % Add the torn lower border
        ($(A.south east)-(0,.2)$) -- ($(A.south west)-(0,.2)$) -- 
        ($(A.south west)+(0,.2)$) -- ($(A.south east)+(0,.2)$) -- cycle;
  \end{pgfonlayer}}}

% Macro to draw the shape, when the text continues from previous page
\def\parchmentframebottom#1{
\tikz{
  \node[inner sep=2em] (A) {#1};   % Draw the text of the node
  \begin{pgfonlayer}{background}   
  \fill[normal border]             % Draw the ``complete shape'' behind
        (A.south east) -- (A.south west) -- 
        (A.north west) -- (A.north east) -- cycle;
  \fill[torn border]               % Add the torn upper border
        ($(A.north east)-(0,.2)$) -- ($(A.north west)-(0,.2)$) -- 
        ($(A.north west)+(0,.2)$) -- ($(A.north east)+(0,.2)$) -- cycle;
  \end{pgfonlayer}}}

% Macro to draw the shape, when both the text continues from previous page
% and it will continue in next page
\def\parchmentframemiddle#1{
\tikz{
  \node[inner sep=2em] (A) {#1};   % Draw the text of the node
  \begin{pgfonlayer}{background}   
  \fill[normal border]             % Draw the ``complete shape'' behind
        (A.south east) -- (A.south west) -- 
        (A.north west) -- (A.north east) -- cycle;
  \fill[torn border]               % Add the torn lower border
        ($(A.south east)-(0,.2)$) -- ($(A.south west)-(0,.2)$) -- 
        ($(A.south west)+(0,.2)$) -- ($(A.south east)+(0,.2)$) -- cycle;
  \fill[torn border]               % Add the torn upper border
        ($(A.north east)-(0,.2)$) -- ($(A.north west)-(0,.2)$) -- 
        ($(A.north west)+(0,.2)$) -- ($(A.north east)+(0,.2)$) -- cycle;
  \end{pgfonlayer}}}

% Define the environment which puts the frame
% In this case, the environment also accepts an argument with an optional
% title (which defaults to ``Example'', which is typeset in a box overlaid
% on the top border
\newenvironment{parchment}[1][Example]{%
  \def\FrameCommand{\parchmentframe}%
  \def\FirstFrameCommand{\parchmentframetop}%
  \def\LastFrameCommand{\parchmentframebottom}%
  \def\MidFrameCommand{\parchmentframemiddle}%
  \vskip\baselineskip
  \MakeFramed {\FrameRestore}
  \noindent\tikz\node[inner sep=1ex, draw=black!20,fill=AmethystPurple, 
          anchor=west, overlay] at (0em, 1em) {\sffamily#1};\par}%
{\endMakeFramed}

% ----------------------------------------------

\mode<presentation>{
    \usetheme{Berkeley}
    % Boadilla CambridgeUS
    % default Antibes Berlin Copenhagen
    % Madrid Montpelier Ilmenau Malmoe
    % Berkeley Singapore Warsaw
    \usecolortheme{dolphin}
    % beetle, beaver, orchid, whale, dolphin
    \useoutertheme{infolines}
    % infolines miniframes shadow sidebar smoothbars smoothtree split tree
    \useinnertheme{circles}
    % circles, rectanges, rounded, inmargin
}
% 设置 block 颜色
\setbeamercolor{block title}{bg=AmethystPurple,fg=white}

\newcommand{\reditem}[1]{\setbeamercolor{item}{fg=red}\item #1}

% 缩放公式大小
\newcommand*{\Scale}[2][4]{\scalebox{#1}{\ensuremath{#2}}}

% 解决 font warning
\renewcommand\textbullet{\ensuremath{\bullet}}

% verbatim


% ---------------------------------------------------------------------
% flow chart
\tikzset{
    >=stealth',
    punktchain/.style={
        rectangle, 
        rounded corners, 
        % fill=black!10,
        draw=white, very thick,
        text width=6em,
        minimum height=2em, 
        text centered, 
        on chain
    },
    largepunktchain/.style={
        rectangle,
        rounded corners,
        draw=white, very thick,
        text width=10em,
        minimum height=2em,
        on chain
    },
    line/.style={draw, thick, <-},
    element/.style={
        tape,
        top color=white,
        bottom color=blue!50!black!60!,
        minimum width=6em,
        draw=blue!40!black!90, very thick,
        text width=6em, 
        minimum height=2em, 
        text centered, 
        on chain
    },
    every join/.style={->, thick,shorten >=1pt},
    decoration={brace},
    tuborg/.style={decorate},
    tubnode/.style={midway, right=2pt},
    font={\fontsize{10pt}{12}\selectfont},
}
% ---------------------------------------------------------------------

% code setting
\lstset{
    language=C++,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{red},
    breaklines=true,
    xleftmargin=2em,
    numbers=left,
    numberstyle=\color[RGB]{222,155,81},
    frame=leftline,
    tabsize=4,
    breakatwhitespace=false,
    showspaces=false,               
    showstringspaces=false,
    showtabs=false,
    morekeywords={Str, Num, List},
}

% ---------------------------------------------------------------------

%% preamble
\title[Halo Parent Finder]{HaloParentFinder}
\subtitle{Big Data Project Transformation}
\author{Fenglai Liu}
\institute[ACCRE]{fenglai@accre.vanderbilt.edu}

% -------------------------------------------------------------

\begin{document}

%% title frame
\begin{frame}
    \titlepage
\end{frame}

% -------------------------------------------------------------

\begin{frame}
%    \frametitle{}

This program is about 2500 lines of code (including comments). Generally this is the first program, there are other two programs
following this one. All of the three forms the entire program set. Below are the general procedure for the halo parent finding program:
\begin{itemize}
 \item Load in parameters. The global parameters are stored in a global struct PARAMS;
 \item Calculate the number of groups - group0 and group1;
 \item Allocate space for group0 and group1 and loading in the group data; 
 \item Finds the hierarchy level (this is for a single snapshot);
 \item Find fof parents for groups in group0 based on group1;
 \item Find all parents for groups in group0 based on group1;
 \item If the halo does not have parent, loop over the remaining snapshot data and repeat the previous steps;
 \item Perform additional checks to make sure the data is consistent.
\end{itemize}


\end{frame}

% -------------------------------------------------------------
\section{Components}

\subsection{Parameters Reading}
\begin{frame}
%    \frametitle{}

The codes for reading the parameters are in the read\_param.c and read\_param.h. The parameters defines
the location of the groups data(input), and output files directory; the limits of snapshots 
and other debugging options (one data file is a snapshot). The developer use a global variable PARAMS to store 
the parameters information. 

\end{frame}

% -------------------------------------------------------------
\subsection{Halo Groups}
\begin{frame}
%    \frametitle{}

``group'' is the central idea for this program - the structure of group is defined in io.h. Group is a collection of particles(Halo). One data file (snapshot)
may containing may groups.

\begin{block}{reading in the group data}
 \begin{itemize}
  \item first line is the the number of groups data;
  \item the following line is the N particles and the halo ID;
  \item after the lines are the particles data, like  x, y, z, vx, vy, vz etc. are all allocated based on the number of particles.
 \end{itemize}
\end{block}


In the code the group\_data pointer is an array of groups. The group data is initialized in the  the loadgroups
function.


\end{frame}

% -------------------------------------------------------------
\begin{frame}
%    \frametitle{}

\begin{block}{The drawback for the design of group data}
  \begin{enumerate}
   \item the design of the group data corresponding to the whole snapshot - not flexible to change. Each time for HaloParentFinder
   we need to load in the all group data in the snapshot, this is the core reason why the memory usage got problem. 
   \item allocate/free group data is cumbersome. Difficult to get the NGroups for the initialization.
   \item parent finding process only use a small portion of group data - however currently we need to carry the whole data 
   to do the process.
   \item the definition of the data structure is hard to modify.
   \item the coding style for the data structure is not clear for maintenance purpose.
  \end{enumerate}
\end{block}

\end{frame}

% -------------------------------------------------------------
\subsection{Functions}
\begin{frame}[fragile]
%    \frametitle{}

\begin{block}{Find Hierarchy}
 Finds the hierarchy level for each snapshot file (group0 and group1). 
\end{block}
This part may not be a costive part since it only runs for a single snapshot. Another point is, this function probably
is the only one uses the particle coordinates like $x$, $y$, $z$ and $xcen$, $ycen$ etc. in the group data.

Therefore, it implies that we can divided the whole group data into two parts:
\begin{itemize}
 \item Part I is for parent finding in terms of group and particles;
 \item Part II contains other data fields that not used for the parent finding. 
\end{itemize}
Such re-configuration can enhance the parent finding efficiency and memory usage.


\end{frame}

% -------------------------------------------------------------
\begin{frame}[fragile]
%    \frametitle{}

\begin{block}{Find fof parents and find all parent}
 \begin{verbatim}
form arrays to extract ID data from group 1;
loop over group data in group0:
     loop over group ID data in group 1:
          compare the ID data between groups;
          update this group data in group0;
          update the corresponding group data in group1;
     end loop
end loop
 \end{verbatim}
\end{block}
Both of the two functions contains similar structure like above. This will be the first key part for big data transformation
and for optimization. Especially for big data application, this part need to be carefully designed to avoid the communication 
penalty.

\end{frame}

% -------------------------------------------------------------
\begin{frame}[fragile]
%    \frametitle{}

\begin{block}{Find parents for remaining groups in group0}
 \begin{verbatim}
loop over remaining snapshot data files:
     free the group1 data array;
     initialize and load in the group1 data array;
     find hierarchy for group1;
     find fof parents and find all parent for group 
     data in group0;
end loop
 \end{verbatim}
\end{block}
this step is to reuse the previous functions so that to searching the remaining unknown parent halos.

\end{frame}

% -------------------------------------------------------------
\begin{frame}[fragile]
%    \frametitle{}

\begin{block}{Remaining functions: check\_fof\_matches and find\_progenitor}
both of the two functions has similar structure with parents finding functions, they are only used
for two adjacent snapshots.
\end{block}

\end{frame}

% -------------------------------------------------------------
\section{Problems and Solutions}
\begin{frame}
%    \frametitle{}

\begin{block}{Code is hard to understand, maintain and improved} 
 \begin{itemize}
  \item abuse use of macro - mixing the debug codes with the production codes;
  \item rigid data structure - parent searching process is cubersome;
  \item code structure is only for loading whole snapshot data - key reason for memory problem;
  \item use of global variables - strong coupling between the functions in the program.
 \end{itemize}
\end{block}

\begin{block}{Suggestion}
 The code needs to be rewritten. In general we can modify the codes so that to solve the memory
 problem, however in this way debugging cost is big. Rewriting may cost several weeks more but
 the final code will be easier for maintaining.
\end{block}

 
\end{frame}

% -------------------------------------------------------------
\subsection{Abuse Use of Macro}
\begin{frame}[fragile]
%    \frametitle{}

a piece of code example in main.c:
 \begin{verbatim}
#ifdef SUBFIND
  my_snprintf(outfname, MAXLEN,"%s/groups_%03d.fofcat", 
       PARAMS.GROUP_DIR,snapshot_number);    
  NFof0 = returnNhalo(outfname);
#endif

#ifndef FOF_ONLY
#define RETURN_ONLY_FOFS 1  
#endif
   
#ifdef SUSSING_TREES
   my_snprintf(outfname,MAXLEN,"%s/%s%05d.z%5.3f.AHF_halos", 
      PARAMS.GROUP_DIR, PARAMS.GROUP_BASE,snapshot_number,REDSHIFT[snapshot_number]);
  NFof0 = returnNhalo_SUSSING(outfname,RETURN_ONLY_FOFS);
#endif

#ifdef BGC2
  my_snprintf(outfname,MAXLEN,"%s/halos_%03d.0.bgc2",  PARAMS.GROUP_DIR, snapshot_number);
  NFof0 = returnNhalo_bgc2(outfname,RETURN_ONLY_FOFS);
#endif  

#ifndef FOF_ONLY  
#undef RETURN_ONLY_FOFS
#endif
 \end{verbatim}

 The mixing of debugging code section and production code sections makes the reading difficult.
 
\end{frame}

% -------------------------------------------------------------
\begin{frame}[fragile]

\begin{verbatim}
# debugging code....
if (params.doDebug(BGC2)) {
   .....
} else if (params.doDebug(FOF_ONLY)) {
   .....
}

# calculate the number of halos
# we can also calculate nhalos for different situations
NFof0 = returnNhalo(params,....)
\end{verbatim}

\end{frame}


% -------------------------------------------------------------
\subsection{Rigid Data and Code Structure}
\begin{frame}

\begin{block}{Why memory is not sufficient?} 
The reason why memory is not sufficient is because the program needs to load in the whole snapshot data for computation. 
One computation needs two snapshots. For large enough snapshot like 150-200GB data this will cause the memory problem.
 \end{block}

\begin{block}{Redesign the data structure}
The data structure for group should be divided into two parts:
 \begin{enumerate}
  \item the normal group data(the normal group data is also used in following two programs?);
  \item group data only for parent finding process.
 \end{enumerate}
 We need to redesign the code structure so that the loading the group data can be performed for part of particle file. 
\end{block}

\end{frame}

% -------------------------------------------------------------
\begin{frame}[fragile]

a general procedure for halo parent finding process:
\begin{verbatim}
# find hierarchy
# it seems the result of find hierarchy only for group level
form normal group data for group0 and group1 to 
   calculate hierarchy (number of parent level);
hold the result into a data structure/file;

# perform finding parents;
form group0 and group1 data only for parent seaching process;
loading in group and possible particles data from particles file;
load in the hierarchy result;
perform finding parent process;
\end{verbatim}

\end{frame}

% -------------------------------------------------------------
\begin{frame}[fragile]

\begin{block}{several questions we need to make it clear in the future:}
 \begin{enumerate}
  \item Can we split the large snapshot file into a collection of files?
  \item How the result of searching process is accessed by other programs?
  \item Do the other two programs also use the normal group data?
  \item Does the big data analysis applicable for this situation?
 \end{enumerate}
\end{block}

\end{frame}

% -------------------------------------------------------------
\section{Outlook for further Improvement}
\begin{frame}[fragile]

Previous suggestions are for step 1. Here is the summary of what we can achieve in the 
step 1:
 \begin{enumerate}
  \item memory issue should be solved;
  \begin{itemize}
   \item use of smaller data structure for searching process;
   \item loading data is flexible - we can either load in whole data file, or part of 
   data file
  \end{itemize}
  \item can be used for more snapshots; 
  \item data should be easier for maintenance and improving purpose;
  \item use of high level programming features such as C++/java for programming.
 \end{enumerate}
 
 \begin{alertblock}{Step1 is necessary}
  Any further improvement must be based on a clear and flexible code structure.
 \end{alertblock}


\end{frame}

% -------------------------------------------------------------
\begin{frame}[fragile]

For step 2, we have two options for consideration:
\begin{block}{big data application transformation}
 \begin{itemize}
 \item  We need to find a situation that big data analysis is applicable here;
 \item  If designed for big data analysis, we need to use Java for implementation.
\end{itemize}
\end{block}

\begin{block}{go parallel}
 We can also use multi-threading such as OpenMP or thread library inside Java to speed up
 the calculation.
\end{block}

\end{frame}

% -------------------------------------------------------------
\section{Cost Estimation}
\begin{frame}
%    \frametitle{}

An applicable cost estimation is hard to make because of two factors:
\begin{itemize}
 \item  lack of background knowledge; 
 \item  original code is hard to analyze.
\end{itemize}

An rough cost estimation for step I implementation:
\begin{itemize}
 \item about 1.5-2 months for code design and code writing;
 \item another 1.5-2 months for debugging and testing.
\end{itemize}


\end{frame}

% -------------------------------------------------------------


\end{document}


