%!TeX encoding = UTF-8
%!TeX program = xelatex
\documentclass[notheorems, aspectratio=54]{beamer}
% aspectratio: 1610, 149, 54, 43(default), 32

\usepackage{latexsym}
\usepackage{amsmath,amssymb}
\usepackage{mathtools}
\usepackage{color,xcolor}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{amsthm}
\usepackage{lmodern} % 解决 font warning
% \usepackage[UTF8]{ctex}
\usepackage{animate} % insert gif

\usepackage{lipsum} % To generate test text 
\usepackage{ulem} % 下划线，波浪线

\usepackage{listings} % display code on slides; don't forget [fragile] option after \begin{frame}
\usepackage{verbatim}
\makeatletter
\def\verbatim@font{\tiny\ttfamily}
\makeatother

% ----------------------------------------------
% tikx
\usepackage{framed}
\usepackage{tikz}
\usepackage{pgf}
\usetikzlibrary{calc,trees,positioning,arrows,chains,shapes.geometric,%
    decorations.pathreplacing,decorations.pathmorphing,shapes,%
    matrix,shapes.symbols}
\pgfmathsetseed{1} % To have predictable results
% Define a background layer, in which the parchment shape is drawn
\pgfdeclarelayer{background}
\pgfsetlayers{background,main}

\definecolor{AmethystPurple}{HTML}{AEAEDF}
% define styles for the normal border and the torn border
\tikzset{
  normal border/.style={AmethystPurple, decorate, 
     decoration={random steps, segment length=2.5cm, amplitude=.7mm}},
  torn border/.style={AmethystPurple, decorate, 
     decoration={random steps, segment length=.5cm, amplitude=1.7mm}}}

% Macro to draw the shape behind the text, when it fits completly in the
% page
\def\parchmentframe#1{
\tikz{
  \node[inner sep=1.5em] (A) {#1};  % Draw the text of the node
  \begin{pgfonlayer}{background}  % Draw the shape behind
  \fill[normal border] 
        (A.south east) -- (A.south west) -- 
        (A.north west) -- (A.north east) -- cycle;
  \end{pgfonlayer}}}

% Macro to draw the shape, when the text will continue in next page
\def\parchmentframetop#1{
\tikz{
  \node[inner sep=2em] (A) {#1};    % Draw the text of the node
  \begin{pgfonlayer}{background}    
  \fill[normal border]              % Draw the ``complete shape'' behind
        (A.south east) -- (A.south west) -- 
        (A.north west) -- (A.north east) -- cycle;
  \fill[torn border]                % Add the torn lower border
        ($(A.south east)-(0,.2)$) -- ($(A.south west)-(0,.2)$) -- 
        ($(A.south west)+(0,.2)$) -- ($(A.south east)+(0,.2)$) -- cycle;
  \end{pgfonlayer}}}

% Macro to draw the shape, when the text continues from previous page
\def\parchmentframebottom#1{
\tikz{
  \node[inner sep=2em] (A) {#1};   % Draw the text of the node
  \begin{pgfonlayer}{background}   
  \fill[normal border]             % Draw the ``complete shape'' behind
        (A.south east) -- (A.south west) -- 
        (A.north west) -- (A.north east) -- cycle;
  \fill[torn border]               % Add the torn upper border
        ($(A.north east)-(0,.2)$) -- ($(A.north west)-(0,.2)$) -- 
        ($(A.north west)+(0,.2)$) -- ($(A.north east)+(0,.2)$) -- cycle;
  \end{pgfonlayer}}}

% Macro to draw the shape, when both the text continues from previous page
% and it will continue in next page
\def\parchmentframemiddle#1{
\tikz{
  \node[inner sep=2em] (A) {#1};   % Draw the text of the node
  \begin{pgfonlayer}{background}   
  \fill[normal border]             % Draw the ``complete shape'' behind
        (A.south east) -- (A.south west) -- 
        (A.north west) -- (A.north east) -- cycle;
  \fill[torn border]               % Add the torn lower border
        ($(A.south east)-(0,.2)$) -- ($(A.south west)-(0,.2)$) -- 
        ($(A.south west)+(0,.2)$) -- ($(A.south east)+(0,.2)$) -- cycle;
  \fill[torn border]               % Add the torn upper border
        ($(A.north east)-(0,.2)$) -- ($(A.north west)-(0,.2)$) -- 
        ($(A.north west)+(0,.2)$) -- ($(A.north east)+(0,.2)$) -- cycle;
  \end{pgfonlayer}}}

% Define the environment which puts the frame
% In this case, the environment also accepts an argument with an optional
% title (which defaults to ``Example'', which is typeset in a box overlaid
% on the top border
\newenvironment{parchment}[1][Example]{%
  \def\FrameCommand{\parchmentframe}%
  \def\FirstFrameCommand{\parchmentframetop}%
  \def\LastFrameCommand{\parchmentframebottom}%
  \def\MidFrameCommand{\parchmentframemiddle}%
  \vskip\baselineskip
  \MakeFramed {\FrameRestore}
  \noindent\tikz\node[inner sep=1ex, draw=black!20,fill=AmethystPurple, 
          anchor=west, overlay] at (0em, 1em) {\sffamily#1};\par}%
{\endMakeFramed}

% ----------------------------------------------

\mode<presentation>{
    \usetheme{Berkeley}
    % Boadilla CambridgeUS
    % default Antibes Berlin Copenhagen
    % Madrid Montpelier Ilmenau Malmoe
    % Berkeley Singapore Warsaw
    \usecolortheme{dolphin}
    % beetle, beaver, orchid, whale, dolphin
    \useoutertheme{infolines}
    % infolines miniframes shadow sidebar smoothbars smoothtree split tree
    \useinnertheme{circles}
    % circles, rectanges, rounded, inmargin
}
% 设置 block 颜色
\setbeamercolor{block title}{bg=AmethystPurple,fg=white}

\newcommand{\reditem}[1]{\setbeamercolor{item}{fg=red}\item #1}

% 缩放公式大小
\newcommand*{\Scale}[2][4]{\scalebox{#1}{\ensuremath{#2}}}

% 解决 font warning
\renewcommand\textbullet{\ensuremath{\bullet}}

% verbatim


% ---------------------------------------------------------------------
% flow chart
\tikzset{
    >=stealth',
    punktchain/.style={
        rectangle, 
        rounded corners, 
        % fill=black!10,
        draw=white, very thick,
        text width=6em,
        minimum height=2em, 
        text centered, 
        on chain
    },
    largepunktchain/.style={
        rectangle,
        rounded corners,
        draw=white, very thick,
        text width=10em,
        minimum height=2em,
        on chain
    },
    line/.style={draw, thick, <-},
    element/.style={
        tape,
        top color=white,
        bottom color=blue!50!black!60!,
        minimum width=6em,
        draw=blue!40!black!90, very thick,
        text width=6em, 
        minimum height=2em, 
        text centered, 
        on chain
    },
    every join/.style={->, thick,shorten >=1pt},
    decoration={brace},
    tuborg/.style={decorate},
    tubnode/.style={midway, right=2pt},
    font={\fontsize{10pt}{12}\selectfont},
}
% ---------------------------------------------------------------------

% code setting
\lstset{
    language=C++,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{red},
    breaklines=true,
    xleftmargin=2em,
    numbers=left,
    numberstyle=\color[RGB]{222,155,81},
    frame=leftline,
    tabsize=4,
    breakatwhitespace=false,
    showspaces=false,               
    showstringspaces=false,
    showtabs=false,
    morekeywords={Str, Num, List},
}

% ---------------------------------------------------------------------

%% preamble
\title[Big Data Analysis In ACCRE]{Big Data Analysis in ACCRE}
\subtitle{Introduction to Scala}
\author{Fenglai Liu}
\institute[ACCRE]{fenglai@accre.vanderbilt.edu}

% -------------------------------------------------------------

\begin{document}

%% title frame
\begin{frame}
    \titlepage
\end{frame}

% -------------------------------------------------------------

\section{What is functional programming(FP)?}
\begin{frame}
%    \frametitle{}

\begin{block}{Imperative Programming(IP)}
Program is built from instructions and data. Like Fortran/C/C++ etc.
\end{block}

\begin{block}{Functional Programming(FP)}
Quoting from Wikipedia: ``functional programming is a programming 
paradigm - a style of building the structure and elements of computer 
programs - that treats computation as the evaluation of mathematical 
functions and avoids changing-state and mutable data.''
\end{block}

\end{frame}

% -------------------------------------------------------------
\begin{frame}
%    \frametitle{}

A typical conceptual example:
\begin{equation}
 g(\omega) = \int_{-\infty}^{+\infty} f(x)\cos(\omega x) dx
\end{equation}

\begin{itemize}
 \item For IP point of view, we think for a given function $f(x)$ how we can do the integration and 
 derive the result Fourier transformation $g(\omega)$;
 \item For FP point of view, we think this is a natural mapping between a general function $f(x)$
 and $g(x)$, and both of the two functions are in the real number fields $\Re$.
\end{itemize}

\end{frame}

% -------------------------------------------------------------
\begin{frame}[fragile]
%    \frametitle{}

FP is a concept. You can use the C to express the FP:

\begin{verbatim}
int abs_sum (int a, int b) {
  int sum = 0;
  sum  = abs(a);
  sum += abs(b);
  return sum;
}
\end{verbatim}

\begin{verbatim}
int abs_sum (int a, int b) {
  retrun abs(a) + abs(b);
}
\end{verbatim}

In the above example, the first example concentrates on how we can derive sum based 
on two input integers step by step. 

In the second example, we consider the abs\_sum function as a transformation between 
abs function based on the integer variables. 

\begin{block}{key features of IP and FP}
 \begin{description}
 \item [IP] instructions on the data
 \item [FP] transformations on the data
\end{description}
\end{block}

\end{frame}

% -------------------------------------------------------------
\section{General feature of Scala}
\begin{frame}[fragile]

General features of Scala:
\begin{itemize}
 \item a mixed language between FP and OOP - ``FP and OOP are orthogonal with each other'';
 \item compiled into Java bytecode and performed on JVM;
 \item seamless integrated with Java, able to reuse many Java packages.
\end{itemize}

Why Scala mixes FP and OOP together? 
\begin{itemize}
 \item support OOP so that to derive the heritage from Java;
 \item support FP so that to use this sharp tool.
\end{itemize}
The bad thing is such a mixture makes the language features complicated.

\end{frame}



% -------------------------------------------------------------
\section{Variable}
\begin{frame}[fragile]

\begin{block}{From IP view, Variable is a chunk of memory in stack or heap}
\begin{verbatim}

// automatic varible
int x = 8;

// struct 
struct address 
{ 
   char name[50]; 
   char street[100]; 
   char city[50]; 
   char state[20]; 
   int zipCode;
};

// array
double arr[100];
\end{verbatim} 
\end{block}
Everything will be finally transformed into instructions on these memory pieces.

\end{frame}


% -------------------------------------------------------------
\subsection{Difference on using variable}
\begin{frame}[fragile]

\begin{block}{Pure FP like Haskell variable is not an abstraction of memory anymore}
For example, in the following Haskell code:
\begin{verbatim}
 let r = 2
 
 // the following lines can not be compiled
 r = 5
 r = r + 4
\end{verbatim}
\end{block}

Here the variable is more like a conceptual symbol. As in the example below, 
the $x$ represents the radius of the cycle, and $y$ is the corresponding area of cycle. $x$ and $y$ correspond to different concepts:
\begin{equation}
y = PI*x^{2}
\end{equation}

\end{frame}

% -------------------------------------------------------------
\begin{frame}[fragile]

In the IP $x$ and $y$ are same type of variable therefore you can use the same variable to do it:
\begin{equation}
x = PI*x^{2}
\end{equation}
This is very common for coding. However this expression is mathematically not correct. In pure FP language it is also not allowed.

However, as a mixed programming Lagrange between OOP and FP, Scala allows the variable to increase itself like $a = a + 1$.
Also the operators like $+=$, $-=$ etc. are all supported in Scala.

\end{frame}

% -------------------------------------------------------------
\subsection{Use of Val}
\begin{frame}[fragile]

Scala introduce a special class to express the immutable variable, 
which is ``val'' (value):
\begin{verbatim}
 val x = 10;
\end{verbatim}
If an object is declared as ``val'', then it can not be changed. Such concept 
is similar to the Java's ``final'' and ``const'' in C++. 

As a FP language, Scala advocates to use ``val'' as much as it can. One main reason is that mutable variables (also with pointers) causes a lot of problem:
\begin{itemize}
 \item serial implementation: segmentation fault, memory leak etc.
 \item parallel implementation: false sharing, racing condition etc.
\end{itemize}
However with immutable variables these problems do not exit.

\end{frame}

% -------------------------------------------------------------
\subsection{Difference on loop structure}
\begin{frame}[fragile]

Because of the essential difference between IP and FP, there's 
significant programming style difference between IP and FP. 

For example, the loop structure:
\begin{verbatim}
for(int i=0; i<n; i++) {
   ....
}
\end{verbatim}
Such loop structure is conceptually ``invalid'' in FP. Then how can we do a loop?

Scala use other tricks to do that (generator expression):
\begin{verbatim}
var a = 0.0;
numList = Lists(1.0  2.0  3.0  4.0);
for( a <- numList ){
   println( "Value of a: " + a );
} 
\end{verbatim}
So there's no ``self-incremental'' operations, the details for the loop is hidden behind the expression. This point makes Scala is similar to Python. 

\end{frame}

% -------------------------------------------------------------
\subsection{Complexity on the containers}
\begin{frame}

The mixture design supporting OOP and FP, the data structures supported by Scala 
then becomes complicated in terms of categories:
\begin{itemize}
 \item mutable data structures;
 \item immutable data structures;
 
\end{itemize}


is divided into two categories:
\begin{itemize}
 \item mutable data structures: list, array, set, queue etc.
 \item immutable data structures: 
\end{itemize}


\end{frame}

% -------------------------------------------------------------
\begin{frame}[fragile]

collections: mutable and immutable.

In Scala Array's element is mutable:
\begin{verbatim}
val numbers = Array(1, 2, 3, 4);
numbers(3)  = 100; 
\end{verbatim}
In Haskell the array is totally immutable because of the FP.

On the other hand, List in Scala is immutable:
\begin{verbatim}
 
\end{verbatim}


\end{frame}

% -------------------------------------------------------------
\section{The difference on functions}
\begin{frame}[fragile]
  
\begin{block}{In IP function is a a collection of actions:}
\begin{verbatim}
// user-defined function to check prime number
int checkPrimeNumber(int n)
{
    int j, flag = 1;

    for(j=2; j <= n/2; ++j)
    {
        if (n%j == 0)
        {
            flag =0;
            break;
        }
    }
    return flag;
}   
\end{verbatim}   
\end{block}
From the machine point of view, function is a reference of instruction set. As
loading the function the function stack will be built, input and output parameters
will be pushed to the stack etc.
  
\end{frame}

% -------------------------------------------------------------
\begin{frame}



\end{frame}

% -------------------------------------------------------------
\begin{frame}

functions and method: function needs something returned.

function and variable are interchangeable

difference between function and method.

function can be very short: lambda function.

function can be another function: high order functions.
. 
\begin{block}{For FP function is a more fundamental piece}
 
\end{block}

  
\end{frame}


% -------------------------------------------------------------
\section{Why use FP for big data analysis?}
\begin{frame}
%    \frametitle{}

 Comparing with Imperative Programming(IP), FP has it's own advantages in programming:
 \begin{itemize}
 \item FP concentrates on the data fields. The focus on FP is how to do transformations on the given data fields, which 
 makes it perfect design for handle data analysis.
 \item Better design for parallel. In FP the variable should be immutable (for example, in pure FP language like Haskell).
 Therefore the parallel design problems(false sharing, racing condition etc.) in IP language like C/Fortran/C++ etc. do not 
 exist. 
 \item More abstraction for code. Because the FP concentrates on more abstract level than IP, usually the code is shorter;
 which makes FP a good candidate for fast development choice.
 \end{itemize} 

\end{frame}

% -------------------------------------------------------------


\end{document}


